---
title: "query-json: A story of cross-compilation with Reason"
date: "2020-10-10"
tags:
  - "query-json"
  - "json"
  - "jq"
  - "Reason"
  - "OCaml"
  - "js_of_ocaml"
  - "jsoo"
---

<!-- TODO: Disclamer Difference between Rescript/Reason/BuckleScript/OCaml -->
# What's query-json

[query-json](https://github.com/davesnx/query-json) is a re-implementation of [jq's language](https://github.com/stedolan/jq/wiki/jq-Language-Description) in Reason Native.

Started with the goal to create something useful and learn during the process. I was interested to learn about how to write parsers and compilers using the OCaml stack: [menhir](https://opam.ocaml.org/packages/menhir) and [sedlex](https://github.com/ocaml-community/sedlex), compile it to any architecture and try to compile it to JavaScript as well.

This post explains the project, how it was made and which decisions where followed.

<!-- ## Why re-implement `jq` - Explain atom-jq and node-jq -->

## Why learning parsers/compilers
<!-- TODO: Simplify this -->

I had a little idea about the theory, but very vague and useless. Since I create [styled-ppx](https://github.com/davesnx/styled-ppx) -which is a
ppx (**P**re**P**rocessor E**x**tension) that allows CSS-in-Reason/OCaml- It needs to parse the CSS and have a backend that compiles to [bs-emotion](https://github.com/ahrefs/bs-emotion). In the future I want to implement a CSS-in-JS solution written in Reason entirely.

I used [astrada/ocaml-css-parser](https://github.com/astrada/ocaml-css-parser) for acomplising the parsing but It's incomplete, so, in order to have full [CSS3]() support I asked for some help to [@EduardoRFS](https://www.twitch.tv/eduardorfs) and made a CSS Parser which I wanted to understand, improve and maintain.

## How it works

```bash
query-json ".store.books | filter(.price > 10)" stores.json
```

This would red the `stores.json` and access to "store" field, access to "books" field, since it's an array, it will run a filter on each item and if "price" field is bigger than 10 will keep that item on the list and finally print the resultant list.

```json
[
  {
    "title": "War and Peace",
    "author": "Leo Tolstoy",
    "price": 12.0
  },
  {
    "title": "Lolita",
    "author": "Vladimir Nabokov",
    "price": 13.0
  }
]
```

The first argument it's called `query` it's a jq expression and the second one `json` or `payload` and it's a valid JSON file.

In order to transform the `query` to a set of operations that run against a JSON, we will need to divide the problem in 3 steps: **parse**, **compile** and **run**.

### Parsing
Responsible for transforming a string into an Abstract Syntax Tree and provide a good error message when the input is malformed.

<!-- Explain what kind of parser LR -->

<!-- Explain this better/copy paste jq-language explaination -->
One of the beauties of `jq` is that all the expressions are piped by default, so
`.store | .books` is equivalent to `.store.books`

If the parser recieves `.store.books` it will give back:

```reason
Pipe(
    Key("store"),
    Key("books")
)
```

All the operations are transformed to these constructors that you can see above (`Pipe`, `Key`), which are called variants. The entire jq program it's one big recursive expression.

These expressions are called [Variants](https://reasonml.github.io/docs/en/variant), it's using one of the best features of Reason, some functional programming communities call it ADT (Algebraic Data Type) which is also correct.

In this case those are GADT (Generic Algebraic Data Type) a kind of ADTs since they contain arguments and those can be recusrive.

Following with a more complex example, let's parse `.store.books | filter(.price > 10)`:

```reason
Pipe(
    Pipe(
        Key("store"),
        Key("books")
    ),
    Filter(
        Pipe(
            Key("price"),
            Literal(Number(10.))
        )
    )
)
```

You can see more examples in the [parsing tests](https://github.com/davesnx/query-json/blob/master/test/ParseTest.re)

### Compile
Compile recieve the AST expression and transforms it to code. It's a big recurive [pattern match](https://reasonml.github.io/docs/en/pattern-matching), which is another great feature of Reason and looks something like this:

```reason
let rec compile = (expression, json) => {
  switch (expression) {
  | Empty => empty
  | Keys => keys(json)
  | Key(key, opt) => member(key, opt, json)
  | Index(idx) => index(idx, json)
  | Head => head(json)
  | Tail => tail(json)
  | Length => length(json)
  /* [...] */
}
```

On the left site are defined all the possible `Variants` and on the right site the operations. Those operations transforms the JSON. Here is where `map`, `filter`, `reduce`, `index`, etc... are implemented.

### Running
The easier part, the compile step give us back a curried function that expects a json as only argument, we just apply the function to a JSON file.

These representations only describe the happy path, in reality all steps of the parsing and compilation return a `Result` type which makes handlings errors more composable.

## Distribution
Now we already covered how it works internally and a little overview of the architecture of query-json. Now let's dive on how developers can use it in their machines.

### How binary cross-compilation works
query-json uses `esy` as a package manager that helps managing either native OCaml and Reason from opam registry or JavaScript packages from npm registry; and `dune` as a build system.

All of the build process and their tests runs on our CI in Github Actions, which allows to run Mac, Windows and Linux images to compile with the OCaml compiler to different architectures.

Once the build is success it pushes the binary into Github Releases and npm registry.

### How compilation to the Web
The compilation to JavaScript is the sweet section of this blog post, since we are using OCaml (under the hood while writting Reason), it allows us to compile directlty to JavaScript using [js_of_ocaml](https://github.com/ocsigen/js_of_ocaml).

Using js_of_ocaml in dune is as easy as adding a flag in the dune file. Using the same build command you have an artifact in JavaScript ðŸ¤¯ . It will compile any library to JavaScript.

As you can see, query-json uses menhir, sedlex and [yojson](https://github.com/ocaml-community/yojson)

In order to use it in esy, I only needed to add
```bash
esy add js_of_ocaml
esy add js_of_ocaml-compiler
```

```clojure
(executable
 (name Js)
 (modes js)
 (libraries console.lib source yojson js_of_ocaml)
)
```

### Made query-json's playground

After having a JavaScript artifact I was able to run it as playground to teach people how to use it or to test new versions on each pull request in the browser.

I build a website using Reason and BuckleScript which uses query-json JavaScript's artifact to run it, you can try it yourself here:

https://query-json.netlify.app

The query-json computation runs sincronous since it's able to run on each key-stroke. Comparing this playground with [jqplay.org](https://jqplay.org/)
where after the blur happens on the input a request needs to hit a backend and respond with the result. It's a massive improvement.

### Benefits

This allows any OCaml backend being able to run in a browser without much hassle, moving logic between the backend and the frontend has been a dream for a lot of Engineering teams.

But not only share logic it's important matters here

#### writting patterns
#### familiarity
- hiring
#### portability
#### usage of OCaml's ecosystem
- libraries and ppxs
- latest ocaml versions

### Challenges
This solution has downsides as well, js_of_ocaml isn't the tool that solves all of your problems, actually there's no such tool.

#### Bundlesize
It's quite big compared to a regular JavaScript application.

The entire playground is about 660kb. Includes the Monaco Editor (~356kb) which the rest is query-json and jsoo runtime (300kb).

jsoo wasn't created with the same mentality as most Frontend developers solve their problems today and was borned X years ago to run some OCaml into a browser.

#### Documentation
One of my bigests complains with OCaml community is the lack of quality documentation. It lacks some of the basics to enable compatibility with JavaScript codebases, modern build systems such as webpack and many bindings to other libraries.

Comming from the JavaScript community (which have more than 9 million devs) there's plenty of tutorials, manuals for newbies, many StackOverflow results and creates this culture of the copy-paste driven development. That gives all sort of problems, but lowers the barrier to the language and the usage of many dependencies out of the box.

It's a non-sense compare OCaml and JavaScript, but one of the biggest missing pieces are good documentation for all levels.

#### Bridge between BuckleScript/Reason and jsoo

This isn't particular to jsoo, is more related to use jsoo and BuckleScript together. In order to run the jsoo artifact into the BuckleScript/Reason codebase, I needed to write bindings for it.

```reason
[@bs.module "../../_build/default/js/Js.bc.js"]
external queryJson: (string, string) => result(string, string) = "run";
```

Using the [Result from OCaml](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Result.html) in the query-json's JavaScript entry-point and the [Result from BuckleScript](https://rescript-lang.org/docs/manual/latest/api/belt/result) in the Reason code I needed to write an unsafe bridge which transforms OCaml result to the internal representation of BuckleScript variant.

There's probably better ways of achiving it since I made the implementation very unsafe [davesnx/query-json/js/Js.re](https://github.com/davesnx/query-json/blob/master/js/Js.re).

### It's a tradeoff, as always...
You can't really compare BuckleScript/rescript with jsoo, since both tools try to solve the same problem in a very different fashion.

If you are writting an OCaml backend and your team is familiar with it. Your project needs to write shared login, doesn't require a hard need on a lower bundlesize and want to carry most dependencies, ppx and patterns from OCaml, jsoo it's a great option.

Since most modern build tools such as Webpack or Rollup allows to lazy import the biggest chunks of your app, you might find no-issue with the big bundle, since most shared logic doesn't require to be present during load-time.

You won't have the facility to write frontend code with React, but I'm sure it will change soon, since there's a current implementation of React in jsso [https://github.com/jchavarri/jsoo-react](https://github.com/jchavarri/jsoo-react).

For now, writting a website in ReasonReact and BuckleScript it's the most robust experience. You can find a lot of bindings to JavaScript libraries, there's a lot of usage in production.

## Future

## Performance





















































































































---

## Performance

This report is not an exhaustive performance report of both tools, it's a overview for the percieved performance of the user. Here I don't profile each tool and try to see what are the bootlenecks, since I assume that both tools have the penalty of parsing a JSON file. Simply run a bash script and analyze the results.

Aside from that, query-json doesn't have feature parity with jq which is ok at this point, but jq contains a ton of functionality that query-json misses. Adding the missing operations on query-json won't affect the performance of it, that could not be true for features like "modules" or "tests", which they will not be implemented in query-json.

The report shows that query-json is between 2x and 5x faster than jq in all operations tested and same speed (~1.1x) with huge files (> 100M).

-

There are a few good asumtions about why query-json is faster, there are just speculations since I didn't profile any of the tools listed here, neither query-json.

Thoughts about jq:

The feature that I think penalizes a lot jq is "def functions", the capacity of define any function that can be available during run-time.

This creates a few layers, one of the difference is the interpreter and the linker, the responsible for getting all the builtin functions and compile them have them ready to use at runtime.

The other pain point is the architecture of the operations on jq, since it's a stack based meanwhile query-json it's a piped recursive operations, and I think OCaml compiler optimizes the piped operations since are tail-recursive.

Aside from the code, the OCaml stack, menhir has been proved to be really fast when creating those kind of compilers.

I will dig more into performance in here and try to profile both tools in order to improve mine.


---




- Explain the benefits
    - Single language, not only patterns. Can use the same ppx's and syntax extensions.
    - Shared types with serialization/des and logic
    - Easy move computations that are expensive to the server
- Explain the bad parts
    - Bundlesize
    - Data representation
    - Standard library
        - OCaml's ones and BuckleScript ones are a mess.
- Close up with a Tradeoff

---

- A call out to all JavaScript
- A call out to rescript

---

- https://medium.com/@itchyny/golang-implementation-of-jq-gojq-ad5bd46a4af2
- https://reasonml.chat/t/intersection-with-ocaml-ecosystem/2036

---