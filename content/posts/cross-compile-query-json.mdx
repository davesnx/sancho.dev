---
title: "query-json: A story of cross-compilation with Reason"
date: "2020-10-12"
tags:
  - "query-json"
  - "json"
  - "jq"
  - "Reason"
  - "OCaml"
  - "js_of_ocaml"
  - "jsoo"
---

<!-- TODO: Disclamer Difference between Rescript/Reason/BuckleScript/OCaml -->

# What's query-json

[query-json](https://github.com/davesnx/query-json) is a faster and simpler re-implementation of [jq's language](https://github.com/stedolan/jq/wiki/jq-Language-Description) in Reason Native.

It's a CLI to run small programs against JSON, the same idea as [sed](https://www.linode.com/docs/tools-reference/tools/manipulate-text-from-the-command-line-with-sed/), but for JSON files. As a web engineer is an essential tool while developing APIs.

Started with the goal to create something useful and learn during the process. Was very interested in learning about how to write parsers and compilers using the OCaml stack: [menhir](https://opam.ocaml.org/packages/menhir) and [sedlex](https://github.com/ocaml-community/sedlex), compile it to any architecture and try to compile it to JavaScript.

This post explains the project, how it was made and which decisions where followed and some reflections.

## Why learning parsers/compilers
I had a little idea about the theory, but very vague and useless. Since I create [styled-ppx](https://github.com/davesnx/styled-ppx) which is a
ppx (**P**re**P**rocessor E**x**tension) that allows CSS-in-Reason/OCaml. Needs to parse the CSS and have a backend that compiles to [bs-emotion](https://github.com/ahrefs/bs-emotion).

I asked for some help to [@EduardoRFS](https://www.twitch.tv/eduardorfs) about writting a CSS Parser that supports the entire [CSS3 specification](https://www.w3.org/TR/2001/WD-css3-roadmap-20010523/) which I will want to understand, improve and maintain over time.

## How it works
```bash
query-json ".store.books | filter(.price > 10)" stores.json
```

This would read `stores.json` and access to `"store"` field, access to `"books"` field, since it's an array, it will run a filter on each item and if `"price" `field is bigger than 10 will keep that item on the list and finally print the resultant list.

```json
[
  {
    "title": "War and Peace",
    "author": "Leo Tolstoy",
    "price": 12.0
  },
  {
    "title": "Lolita",
    "author": "Vladimir Nabokov",
    "price": 13.0
  }
]
```

The first argument it's called `query` it's a jq expression and the second one `json` or `payload` and it's a valid JSON file.

The semantics of jq consists of a set of piped operations, where each output is connected to an input where the first input it's the JSON itself. Some pseudo-code to ilustate:

```
{ /* json */ } | filter | transform | count
```

In order to transform the `query` to a set of operations that run against a JSON, we will divide the problem in 3 steps: **parse**, **compile** and **run**.

### Parsing
Responsible for transforming a string into an Abstract Syntax Tree and provide a good error message when the input is malformed.

<!-- Explain what kind of parser LR -->

<!-- Explain this better/copy paste jq-language explaination -->
One of the beauties of `jq` is that all the expressions are piped by default, so `.store | .books` is equivalent to `.store.books`. I designed the AST to represent the pipe structure in it's nature.

Let's dive into an example. When the parser recieves `.store.books` will return:

```reason
Pipe(
    Key("store"),
    Key("books")
)
```

All the operations are transformed to these constructors that you can see above (`Pipe`, `Key`).

These expressions are called [Variants](https://reasonml.github.io/docs/en/variant), are one of the best features of Reason, some functional programming communities call it *ADT* (Algebraic Data Type) which is also correct.

In this case those are *GADT* (Generic Algebraic Data Type) a kind of *ADTs* since they contain arguments and those can be recursive. The entire `query-json` program representation it's one big recursive Variant.

Following with a more complex example, let's parse `.store.books | filter(.price > 10)`:

```reason
Pipe(
    Pipe(
        Key("store"),
        Key("books")
    ),
    Filter(
        Pipe(
            Key("price"),
            Literal(Number(10.))
        )
    )
)
```

You can see more examples in the [parsing tests](https://github.com/davesnx/query-json/blob/master/test/ParseTest.re)

### Compiling
Compile recieve the *AST* expression and transforms it to code. It's a big recurive [pattern match](https://reasonml.github.io/docs/en/pattern-matching), which is another great feature of Reason and looks something like this:

```reason
let rec compile = (expression, json) => {
  switch (expression) {
  | Empty => empty
  | Keys => keys(json)
  | Key(key, opt) => member(key, opt, json)
  | Index(idx) => index(idx, json)
  | Head => head(json)
  | Tail => tail(json)
  | Length => length(json)
  /* [...] */
}
```

On the left site are defined all the possible `Variants` and on the right site the operations. Those operations transforms the JSON. Here is where `map`, `filter`, `reduce`, `index`, etc... are implemented.

### Running
The easier part, the compile step give us back a curried function that expects a json as only argument, we just apply the function to this JSON and print the result.

This example only describe the happy path, in reality the parsing and compilation steps return a `Result` type which allows handling errors more composable.

# Distribution
Now we already covered how it works internally and a little overview of the architecture. Now let's dive on how developers can use it in their machines.

## How to cross-compilation to binary
query-json uses `esy` as a package manager that helps managing either native OCaml and Reason from opam registry or JavaScript packages from npm registry; and `dune` as a build system.

All of the build process and their tests runs on our CI in Github Actions, which allows to run Mac, Windows and Linux images to compile with the OCaml compiler to different architectures.

Once the build is success it pushes the binary into Github Releases and npm registry.

## How compile to the Web
The compilation to JavaScript is the sweet section of this blog post, since we are using OCaml (under the hood while writting Reason), it allows us to compile directlty to JavaScript using [js_of_ocaml](https://github.com/ocsigen/js_of_ocaml).

Using js_of_ocaml in dune is as easy as adding a flag in the dune file. Using the same build command you have an artifact in JavaScript ðŸ¤¯ . It will compile any library to JavaScript.

As you can see, query-json uses menhir, sedlex and [yojson](https://github.com/ocaml-community/yojson)

In order to use it in esy, I only needed to add
```bash
esy add js_of_ocaml
esy add js_of_ocaml-compiler
```

```clojure
(executable
 (name Js)
 (modes js)
 (libraries console.lib source yojson js_of_ocaml)
)
```

## Made query-json's playground

After having a JavaScript artifact I was able to run it as playground to teach people how to use it or to test new versions on each pull request in the browser.

I build a website using Reason and BuckleScript which uses query-json JavaScript's artifact to run it, you can try it yourself here:

https://query-json.netlify.app

The query-json computation runs sincronous since it's able to run on each key-stroke. Comparing this playground with [jqplay.org](https://jqplay.org/)
where after the blur happens on the input a request needs to hit a backend and respond with the result. It's a massive improvement.

### Benefits
This allows any OCaml backend being able to run in a browser without much hassle, sharing code between backend and frontend has been a dream for a lot of Engineering teams.

But not only share logic matters, here's a list of other upsides:

- **Portability**, moving code from server to client or viceversa, sharing marshal/unmarshal code, easier contract testing.
- **Familiarity**: Writting the same patterns would benefit new commers that need to learn less platform specific rules.
- **Usage of OCaml's ecosystem**: Access to many libraries and ppxs and latests ocaml's features.

### Challenges
This solution has downsides as well, js_of_ocaml isn't the tool that solves all of your problems, actually there's no such tool.

#### Bundlesize
It's quite big compared to regular JavaScript applications.

The entire playground is about 660kb. Includes the Monaco Editor (~356kb) and the rest is query-json and jsoo runtime (300kb).

jsoo wasn't created with the same mentality as most Frontend developers solve their problems today and was borned 10 years ago to run some OCaml into a browser.

#### Documentation
One of my biggest complains about the OCaml community is the lack of quality documentation.

Comming from the JavaScript community (which have more than 9 million devs) there's plenty of tutorials, examples, manuals, many StackOverflow resolved questions and this culture of the copy-paste driven development.

That gives all sort of problems, but lowers the barrier to the language and the usage of many dependencies for new commers or not so passionate FP developers.

It's a non-sense compare OCaml and JavaScript, but one of the biggest missing pieces are good documentation at all levels.

#### Bridge between BuckleScript/Reason and jsoo
It lacks some of the basics to enable compatibility with JavaScript codebases, modern build systems such as webpack and many bindings to other libraries.

This isn't particular to jsoo, is more related to use jsoo and BuckleScript together. In order to run the jsoo artifact into the BuckleScript/Reason codebase, I needed to write bindings for it.

```reason
[@bs.module "../../_build/default/js/Js.bc.js"]
external queryJson: (string, string) => result(string, string) = "run";
```

Using the [Result from OCaml](https://caml.inria.fr/pub/docs/manual-ocaml/libref/Result.html) in the query-json's JavaScript entry-point and the [Result from BuckleScript](https://rescript-lang.org/docs/manual/latest/api/belt/result) in the Reason code I needed to write an unsafe bridge which transforms OCaml result to the internal representation of BuckleScript variant.

There's probably better ways of achiving it since I made the implementation very unsafe [davesnx/query-json/js/Js.re](https://github.com/davesnx/query-json/blob/master/js/Js.re).

### It's a tradeoff, as always...
You can't really compare BuckleScript/rescript with jsoo, since both tools try to solve the same problem in very different fashion.

If you are writting an OCaml backend and your team is familiar with it. Your project would benefit from sharing code, don't require a hard need on a lower bundlesize and want to carry all OCaml dependencies, ppx and patterns, jsoo it's the best option.

Since most modern build tools such as [Webpack](https://webpack.js.org/) or [Rollup](https://rollupjs.org) allows to lazy import chunks of your app, you might find no-issue with the big bundle, since most shared logic doesn't require to be present during load-time.

You won't have the facility to write frontend code with React, but I'm sure it will change soon, since there's a current implementation of React in jsso [https://github.com/jchavarri/jsoo-react](https://github.com/jchavarri/jsoo-react).

For now, writting a website in ReasonReact and BuckleScript it's the most robust experience. You can find a lot of bindings to JavaScript libraries, there's a lot of usage in production, plenty of examples.

I truly believe that [ReScript](https://rescript-lang.org) it's such a great project to target JavaScript developers that found TypeScript slow and liar, or Flow abandoned. It improves the status quo for many issues regarding the Reason Community and keeps delivering in a fast pace the best tooling.

It makes me very sad that ReScript will diverge at some point from the OCaml ecosystem and won't spend time on build a cross-platform language with the advantatges of cross-compilation and future features from OCaml.

# Future
The future of query-json is to provide a better experience on running operations on top of JSON.

Providing better error messages and better performance has been the goal.

Currenlty jq has an issue, it's very powerful but confusing. The amount of questions of StackOverflow proves that there's a lot of problems without a solution on the language/compiler.

The other mission of query-json is to push performance forward, now we are implementing most of the missing functionality since I first release it and next is to explore performance optimizations, such as:

- Replacing menhir with a written parser/lexer
- Using OCaml multicore
- Partial JSON parsing, only parse the needed parts of a json based on the user's query

## Final




















































































































---

## Performance

This report is not an exhaustive performance report of both tools, it's a overview for the percieved performance of the user. Here I don't profile each tool and try to see what are the bootlenecks, since I assume that both tools have the penalty of parsing a JSON file. Simply run a bash script and analyze the results.

Aside from that, query-json doesn't have feature parity with jq which is ok at this point, but jq contains a ton of functionality that query-json misses. Adding the missing operations on query-json won't affect the performance of it, that could not be true for features like "modules" or "tests", which they will not be implemented in query-json.

The report shows that query-json is between 2x and 5x faster than jq in all operations tested and same speed (~1.1x) with huge files (> 100M).

-

There are a few good asumtions about why query-json is faster, there are just speculations since I didn't profile any of the tools listed here, neither query-json.

Thoughts about jq:

The feature that I think penalizes a lot jq is "def functions", the capacity of define any function that can be available during run-time.

This creates a few layers, one of the difference is the interpreter and the linker, the responsible for getting all the builtin functions and compile them have them ready to use at runtime.

The other pain point is the architecture of the operations on jq, since it's a stack based meanwhile query-json it's a piped recursive operations, and I think OCaml compiler optimizes the piped operations since are tail-recursive.

Aside from the code, the OCaml stack, menhir has been proved to be really fast when creating those kind of compilers.

I will dig more into performance in here and try to profile both tools in order to improve mine.


---




- Explain the benefits
    - Single language, not only patterns. Can use the same ppx's and syntax extensions.
    - Shared types with serialization/des and logic
    - Easy move computations that are expensive to the server
- Explain the bad parts
    - Bundlesize
    - Data representation
    - Standard library
        - OCaml's ones and BuckleScript ones are a mess.
- Close up with a Tradeoff

---

- A call out to all JavaScript
- A call out to rescript

---

- https://medium.com/@itchyny/golang-implementation-of-jq-gojq-ad5bd46a4af2
- https://reasonml.chat/t/intersection-with-ocaml-ecosystem/2036

---