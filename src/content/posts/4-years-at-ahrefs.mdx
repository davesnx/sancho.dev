---
title: "Learnings after 4 years at ahrefs"
publishedAt: "2024-10-12"
isDraft: true
tags:
- "ahrefs"
- "Open Source"
- "Work"
---

During the pandemic I worked on a side-project [styled-ppx](https://styled-ppx.vercel.app) that got me into ahrefs. Javi helped me with the setup, and explaining a bunch of concepts about the OCaml ecosytem. What I consider now to be a closer friend. He worked (and still does) at ahrefs, that's how I got to know the company better.

Fast forward 4 years, I've been working at ahrefs and it truly feels like I've found my dream job. While the concept of a dream job sounds idealistic and silly, far from a perfect job, it looks like the job I always wanted: working on projects driven by passion, tackling big problems with complete autonomy, and everything I do is Open Source and built with "the community" in mind.

Ahrefs team works mostly remotely but has offices in Singapore, San Francisco and Japan. The team is spread over five different timezones. This made me a bit of a nomad, spending winters in the Pyrenees, locked in, skiing and peacefully enjoying nature. Summers are for running and cycling closer to family in Barcelona, Spain.

It's one of the most unusual companies I've encountered, and in this post I want to explain what I means for me, and what I have learned in those 4 years.

If I ever feel a bit sad or nostalgic, I can return to this post and smile. Let's go.

# What's ahrefs?

Let me explain first what the company is about and why it's such a rare place. Eventually I'll get to the learnings.

Only marketing people, SEO specialists, and OCaml fans have heard of [ahrefs.com](http://ahrefs.com).

We're one of the top SEO tools in the world, helping users improve their search rankings on Google, Bing, YouTube, Amazon, and now OpenAI and company. To show off a bit with the numbers: ~45% of the S&P 500 use us, and we have ~50k clients including Facebook, Nike, Adobe, IBM, and Pinterest.

In short, we actually crawl the entire web and organize all that raw data into useful insights via different tools and reports. Those tools help people analyze the world, their own site, their competitors' sites, rankings, authority, and a million other thingsâ€”and eventually get more traffic from search engines.

Lately we've released [Web analytics](https://ahrefs.com/web-analytics), we have our own search engine called [Yep.com](http://Yep.com) (still in beta) and we're building other AI projects like Wordcount ([wordcount.com](http://wordcount.com)) and Brand Radar.

It's worth noting that, as with any powerful tool, there are bad actors. Some practitioners employ SEO tactics that prioritize clickbait over substance, crafting those awful headlines like "Top 10 moments from last night's event, you won't believe number 7!" They're honestly one of the worst things about the internet. But we've built something genuinely useful for anyone seeking to establish a meaningful presence online. How our tools are used ultimately reflects the intentions of those who use them.

# The underdog company

Before joining, I only knew that the company was doing "SEO with OCaml stuff" with just a few people and competing directly with tech giants like Google, Bing, and Baidu in crawling.

Most companies tackling internet-scale problems have thousands of engineers. We're ~120 and have no plans to grow beyond that. This caught my attention immediately. Staying small seemed challenging.

We run one of the most active crawlers in the world, processing 5 million pages every minute which is around 7 billion pages daily. Despite this genuinely staggering scale, we maintain the agility and focus that only comes from staying deliberately small, being extremely good at our craft, and choosing the right tech.

# The tech

Our secret? Everything is written in OCaml. The backend, frontend, crawler, devops, internal tools, and even the CI.

The story starts with the crawler. We needed an expressive and performant language to process billions of pages daily, and OCaml delivered. It went so well that it gradually spread across the entire backend, then eventually reached the frontend.

Originally, we had PHP for the backend and React for the frontendâ€”standard choices. But when OCaml proved its worth in the crawler, the backend followed. On the frontend, we faced a choice: TypeScript (or Flow, remember that?) or Reason. Since Reason is essentially OCaml with JavaScript-friendly syntaxâ€”sharing the same type system, semantics, tooling, and ecosystemâ€”adopting it was a no-brainer.

This gave us something powerful: a truly unified tech stack.

Our REST endpoints share the exact same type definitions as our frontend. Our SSR server reuses the same React components as the client. Our data validation logic runs identically on both sides. Change a type definition once, and the compiler catches mismatches across the entire stackâ€”no manual synchronization, no drift between client and server.

Here's a concrete example: last month we added a new field to our backlink data structure. The compiler immediately flagged 47 locations across our codebase that needed updatesâ€”from database queries to API responses to UI components. No runtime surprises, no "undefined is not a function" in production. Just compile-time safety end-to-end.

But this isn't just about type safety. We use the same package manager (opam), the same build system (dune), the same LSP for our editor, and deploy everything through a single pipeline. One language to learn, one mental model to master. It lowers the learning curve and eliminates context switching. A newcomer joins the team, learns a single way of thinking, and suddenly they can contribute anywhere in the stack.

While Reason is the language of choice for the frontend, we use Melange to compile to JavaScript. We're actually one of Melange's main sponsors, and I'm part of the core teamâ€”but more on that later.

Aside from the unusual language choice, there's another peculiarity: the engineering team is pretty much NIH maxing.

In a small ecosystem like OCaml, building for the long term often means owning your dependencies. We use some third-party tools like ClickHouse and Buildkite, but most critical pieces are built in-house. It sounds extreme, but I'd rather modify and maintain code I understand than trust something I can't control or fix when it breaks at 3 AM.

# Learnings

Finally, the learnings. Might be highly personal and contextual but still somehow applicable in other places.

## "Bootstrap" and "technology-first" rocks

The CEO makes decisions based on his view of the company, his opinions and the market. He's strong He appears in technical discussions, shares his quiet view. Our CEO codes, our CTO codes. This isn't just philosophyâ€”they're in the codebase.

This happens because we're bootstrap. No external pressure from VCs pushing for growth metrics or exit strategies. Previously I've been at companies where entire roadmaps got shaped by investors' opinions, which conflicted with the CEO's vision. Here? If something is technically interesting and solves a real problem, we can just build it.

By focusing on OCaml, we hire talented people who care about their craft. When you bring passionate people together, it generates great solutions and energy. server-reason-react was born from thisâ€”a real technical need (duplicate server/client implementations), someone passionate enough to tackle it, and the freedom to explore it without business cases or approval chains.

That's the bootstrap difference: we can work on hard technical problems because we need them, not because they look good in a pitch deck.

## The culture can be daunting, but it's extremly effective

The culture is a mix of international people but with Eastern European roots, inherited from our Ukrainian founders. Direct communication, pragmatism, rationality over anything else.

Being async-first shapes everything. Discussions happen in public threads that might run for weeks. No quick Slack DMs or hallway conversationsâ€”everything is written, searchable, and thoughtful. This forces precise communication and builds trust across time zones.

Coming from Spain, this caught me completely off guard. I'd worked at two US-culture companies before, where feedback came wrapped in compliment sandwiches and party emojis. The Spanish way? We soften criticism with warmth. At ahrefs? Pure, unfiltered directness.

Here's what I mean: if your solution has problems, someone will simply write "This won't scale. Try approach B instead." No emoji cushioning, no "great effort but...", no paragraph explaining how valued you are before the critique. In most places, even terrible solutions get celebrated with "Good start! ðŸŽ‰" followed by gentle suggestions.

At first, this felt harsh. But after a few months, I could confidently say it's incredibly effective. The solution isn't attached to your identity or personalityâ€”it's just code or decisions that can be improved. Once you internalize this, you iterate faster with actually valuable feedback instead of decoding what people really think.

This efficiency extends everywhere. With less than an hour of meetings per week, I can actually focus on solving hard problems instead of talking about solving them.

## Being remote doesn't mean strangers

There's a clear personal barrier with remote work. The person who's been reviewing your code for years is just an avatar (If you're lucky, they have their actual face).

Ahrefs does something clever here. Investing in real-life events. Sponsoring tech conferences like ICFP, fun-OCaml, or React Alicante, and bringing the team together. We also do a ski retreat each year and other hacking-together events.

These gatherings transform our remote culture.

Back home, when someone challenges your PR, you hear their actual voice in your head, not some imagined critical tone. You know they're coming from a place of wanting the best solution because you've seen them fight just as hard for their own ideas at 3 AM in some conference hotel lobby.

## There's a mile between prototyping and engineering

Most of my work at ahrefs involves building tools for other engineers. Libraries, compilers, frameworks, build system improvements. The kind of stuff that lives one layer below the actual product.

It's easy to fall in love with the prototype, with the idea. Ignoring edge-cases, real world use cases and the messy reality of production.

I might spend two weeks building something elegant, all tests passing, look shiny on the demo folder. Then comes integration with the main repo. Half my assumptions are wrong. The API doesn't actually fit. Edge cases I never imagined break everything.

I keep reminding myself that real engineering is done when the integration, edge cases, errors and documentation + teaching the team is done. Meanwhile this doesnâ€™t happen, it's beta and lives in the world of ideas.

As engineers, we got hired to solve problems. Ideas are probably a first step, same as prototyping or researching. At the start I kept falling into the trap of spending suboptimal amounts of time perfecting prototype, where the value is in engineering: making it robust, integrable, understandable.

# Final notes

