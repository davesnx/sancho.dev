---
title: "Parser combinators for dummies"
publishedAt: "2025-10-12"
isDraft: true
tags:
  - "OCaml"
  - "Parsers"
  - "Angstrom"
description: "A practical guide to parser combinators"
---

{/*
ASSESSMENT

1) Opinion on quality and voice
- Very strong educational draft. The tone is friendly, practical, and actually beginner-safe without being condescending.
- The narrative arc (regex pain -> core idea -> building blocks -> full parser) is excellent and easy to follow.
- Code samples are well chosen and progressive, with enough explanation to teach mental models, not just syntax.

2) What's missing or weak
- There is no dedicated section on tradeoffs: when parser combinators become awkward, performance caveats, backtracking pitfalls.
- Error handling is introduced, but debugging strategies (tracing parser position, isolating failing combinator) are still light.
- The post says "for dummies" but a few terms (applicative/backtracking behavior) might still need one-sentence clarifications.
- Missing a compact final checklist readers can use when designing their own parser.

3) How I would finish it
- Add a section "Common gotchas" with concrete cases:
  - greedy parsers consuming too much,
  - `<|>` behavior when input is consumed,
  - whitespace handling,
  - quoted string escapes.
- Add one section "Debugging workflow" with a repeatable process:
  1. test smallest parser first,
  2. compose incrementally,
  3. attach `<?>` labels early,
  4. keep failing input fixtures.
- Add a tiny benchmark note or practical guidance on when to consider Menhir for full language grammars.
- End with a "build-your-own" exercise: parse mini-INI/CSV/log format with 3 progressive tasks.
- Tighten the final paragraph into a memorable ending line + "what to try next this weekend."

4) Hero image and visual concepts
- Hero image options:
  - Side-by-side "Regex wall of symbols" vs "Composable parser blocks".
  - Conveyor belt diagram where chunks of input pass through parser stages.
  - Whiteboard-style "A | B | many(A)" visual with arrows and highlighted consumed text.
- In-article visuals:
  - Annotated log line with color-coded parser responsibility.
  - State progression strip: remaining input after each combinator.
  - Flowchart of parser failure paths with improved labeled errors.
*/}

I was very interested in learning how to write a parser, mostly by hand and avoid a grammar generation (such as yacc or menhir) Since I can't help myself and love Functional programming, Parser combinators had been on my radar for a while. I mostly bounced off a few times from Haskell tutorials because of the monad explanations (and not being an expert in Haskell lol).

When I finally break thought and learned them, I was surprised how simple the core idea is. This post is what I wish someone had shown me, from PROBLEM -> IDEA -> IMPLEMENTATION.

## The problem: regex hell

Say you're building a tool that reads a custom log format. Each line looks like this:

```
[2024-03-15 14:32:01] INFO server: Request completed in 234ms (user_id=42, path="/api/users")
```

You need to extract the timestamp, level, source, message, and those key-value pairs in parentheses. The key-value pairs are optional, and there can be any number of them.

Here's what a regex might look like:

```ocaml
let pattern = {|\[(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})\] (\w+) (\w+): (.+?)(?:\s+\((.+)\))?$|}
```

Quick: what does `(?:\s+\((.+)\))?$` match? Even if you wrote this yesterday, you'd need to trace through it character by character and probably open an online playground. This is *write-only code*. Easy enough to produce when you're in the zone, nearly impossible to read later.

And it only gets worse. Add support for nested parentheses in values, handle escaped quotes, make the timestamp format flexible, add meaningful error messages when parsing fails. Each change means editing that dense string and hoping you don't break something else. There's no way to test the "timestamp part" in isolation. It's all or nothing. When it fails, you get "no match." Good luck figuring out *where* it went wrong.

If you've ever tried to parse HTML with regex, you've probably seen [this legendary Stack Overflow answer](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags). A dramatic reminder that regex fundamentally can't handle nested structures. Our log format isn't as bad as HTML, but the moment you need recursive patterns, regex falls apart.

## The core idea

Parser combinators fix this with divide-and-conquer. Instead of one big regex that matches everything, you write tiny parsers that each handle one thing, then compose them together.

Think of it like functions. You wouldn't write one giant function that does everything. You write small functions and compose them. Parser combinators are the same idea applied to parsing.

A parser is a function that takes some input (a string), tries to match something at the current position, and either succeeds or fails. When it succeeds, it returns what it matched *plus the remaining input*. That remaining input is what makes composition possible: one parser consumes its piece, then hands the rest to the next parser.

{/* image: Diagram showing a string "[2024-03-15] INFO server:" flowing through three connected boxes labeled "timestamp", "level", and "source". Each box consumes its portion and passes the rest forward. Arrow from input string enters "timestamp" box, shorter string exits and enters "level" box, even shorter string exits and enters "source" box. */}

There are three ways to compose parsers. **Sequence**: parse A, then parse B. **Choice**: try A, if it fails try B. **Repetition**: parse A zero or more times. Everything else is built from these three.

## Enter Angstrom

[Angstrom](https://github.com/inhabitedtype/angstrom) is OCaml's go-to parser combinator library. It's fast, memory-efficient, and has a clean API.

```bash
opam install angstrom
```

And in your dune file:

```lisp
(library
  (name my_parser)
  (libraries angstrom))
```

## Building blocks

Let's start small. A parser that matches one or more digits and turns them into an integer:

```ocaml
open Angstrom

let integer =
  take_while1 (function '0'..'9' -> true | _ -> false)
  >>| int_of_string
```

`take_while1` keeps consuming characters while the predicate is true. The `1` means "at least one": if there are zero digits, it fails. The `>>|` operator (pronounced "map") transforms the result, like `List.map` but for parsers. This reads: "take one or more digits, then convert the string to an int."

```ocaml
parse_string ~consume:All integer "42"
(* Ok 42 *)

parse_string ~consume:All integer "abc"
(* Error ": take_while1" *)
```

## Composing parsers

Now let's parse a key-value pair like `name=david`. We need three things in sequence: an identifier, an equals sign, and another identifier.

```ocaml
let identifier =
  take_while1 (function
    | 'a'..'z' | 'A'..'Z' | '_' -> true
    | _ -> false)

let key_value =
  identifier >>= fun key ->
  char '=' >>= fun _ ->
  identifier >>= fun value ->
  return (key, value)
```

The `>>=` operator sequences parsers. It says: "run the first parser, take its result, and feed it to the next one." This works, but it's verbose. Angstrom supports `let*` syntax which reads much better:

```ocaml
let key_value =
  let* key = identifier in
  let* _ = char '=' in
  let* value = identifier in
  return (key, value)
```

Same thing, but it looks like regular OCaml code. There's also a more concise style with applicative operators:

```ocaml
let key_value =
  lift2 (fun k v -> (k, v))
    (identifier <* char '=')
    identifier
```

`lift2` takes a function and two parsers, runs both, and applies the function to their results. The `<*` operator means "parse both sides, keep the left result." Its mirror `*>` keeps the right. So `identifier <* char '='` parses an identifier followed by `=`, but only returns the identifier.

I tend to use `let*` for anything with more than two parsers, and `lift2`/`lift3` for short combinations. Pick whichever reads best for the situation.

## Choices and alternatives

What if values can be either identifiers or quoted strings? First, a parser for quoted strings:

```ocaml
let quoted_string =
  char '"' *>
  take_while (fun c -> c <> '"') <*
  char '"'
```

This reads left to right: consume a `"`, take everything that isn't a `"`, consume the closing `"`. The `*>` and `<*` operators throw away the quotes and keep only the content between them.

Now we can offer a choice:

```ocaml
let value = quoted_string <|> identifier
```

The `<|>` operator tries the first parser. If it fails without consuming input, it tries the second.

```ocaml
parse_string ~consume:All value {|"hello world"|}
(* Ok "hello world" *)

parse_string ~consume:All value "simple"
(* Ok "simple" *)
```

## Repetition

To parse multiple key-value pairs separated by commas:

```ocaml
let pairs = sep_by (char ',' *> skip_many (char ' ')) key_value
```

`sep_by` takes a separator parser and an item parser, returning a list. Other useful repetition combinators: `many` for zero or more, `many1` for one or more, `count n` for exactly n times.

```ocaml
parse_string ~consume:All pairs "a=b, c=d, e=f"
(* Ok [("a", "b"); ("c", "d"); ("e", "f")] *)
```

## Putting it together: the log parser

Now let's tackle that log format from the beginning. Here's the structure, broken down:

{/* image: The log line with each segment annotated, showing which parser handles it:

[2024-03-15 14:32:01]  INFO  server:  Request completed in 234ms  (user_id=42, path="/api/users")
└──── timestamp ─────┘  level └source┘  └────── message ───────┘  └──────── metadata ─────────┘
*/}

First, the types:

```ocaml
type log_entry = {
  timestamp: string;
  level: string;
  source: string;
  message: string;
  metadata: (string * string) list;
}
```

Then, piece by piece:

```ocaml
let timestamp =
  char '[' *>
  take_while (fun c -> c <> ']') <*
  char ']'

let level =
  take_while1 (function 'A'..'Z' -> true | _ -> false)

let source =
  take_while1 (function 'a'..'z' | '_' -> true | _ -> false) <*
  char ':'

let spaces = skip_many (char ' ')

let metadata_value =
  quoted_string
  <|> take_while1 (fun c -> c <> ',' && c <> ')')

let metadata_pair =
  lift2 (fun k v -> (k, v))
    (take_while1 (fun c -> c <> '=') <* char '=')
    metadata_value

let metadata =
  char '(' *>
  sep_by (char ',' *> spaces) metadata_pair <*
  char ')'

let message_text =
  take_while (fun c -> c <> '(' && c <> '\n')

let log_entry =
  let* ts = timestamp <* spaces in
  let* lvl = level <* spaces in
  let* src = source <* spaces in
  let* msg = message_text in
  let* meta = option [] (spaces *> metadata) in
  return {
    timestamp = ts;
    level = lvl;
    source = src;
    message = String.trim msg;
    metadata = meta;
  }
```

Notice that `metadata_value` reuses the `quoted_string` parser we wrote earlier. That's the whole point of this approach: small parsers snap together into bigger ones.

Let's test it:

```ocaml
let input = {|[2024-03-15 14:32:01] INFO server: Request completed in 234ms (user_id=42, path="/api/users")|}

let result = parse_string ~consume:All log_entry input
(* Ok {
  timestamp = "2024-03-15 14:32:01";
  level = "INFO";
  source = "server";
  message = "Request completed in 234ms";
  metadata = [("user_id", "42"); ("path", "/api/users")]
} *)
```

Compare this to the regex. Yes, it's more code. But read it out loud. `timestamp`, `level`, `source`, `metadata_pair`. You know what each piece does. You can test `metadata_pair` by itself without running the full parser. When you need to add a new field next week, you write a small parser and slot it in. Try doing that to a regex without breaking something.

## Error handling

One of the best things about parser combinators: error messages. The `<?>` operator attaches a label to a parser. When it fails, the error message uses this label instead of a cryptic internal name:

```ocaml
let level =
  take_while1 (function 'A'..'Z' -> true | _ -> false)
  <?> "log level (e.g., INFO, ERROR, DEBUG)"
```

```ocaml
parse_string ~consume:All log_entry "[2024-03-15] info server: test"
(* Error ": log level (e.g., INFO, ERROR, DEBUG)" *)
```

Compare that to regex's "no match." You actually know what went wrong and where.

For validation beyond syntax, use `fail` to reject values that parse correctly but aren't valid:

```ocaml
let valid_level =
  level >>= fun l ->
  if List.mem l ["DEBUG"; "INFO"; "WARN"; "ERROR"] then
    return l
  else
    fail (Printf.sprintf "unknown log level: %s" l)
```

## When to reach for them

Parser combinators shine when the format has structure: nested brackets, recursive patterns, context-sensitive parsing. They're worth it when you need good error messages, when the format will evolve, or when you want to test pieces in isolation.

Stick with regex when the pattern is genuinely simple. Email validation, phone numbers, search-and-replace. No point writing a combinator for something `String.split` can handle.

For full programming language grammars, consider parser generators like [Menhir](http://gallium.inria.fr/~fpottier/menhir/) instead. They handle ambiguity and produce efficient parsers, but require learning a separate grammar syntax.

---

Parser combinators aren't magic. They're small functions that compose well. Once that clicks, you start seeing parsing problems differently. Not "what regex matches this?" but "what are the pieces, and how do they fit together?"

The [Angstrom documentation](https://ocaml.org/p/angstrom/latest/doc/Angstrom/index.html) is thorough, and if you want to see how they work under the hood, [this implementation](https://gist.github.com/yawaramin/75f0a35ece0cc7cf208d6c04e6e82bb9) builds one from scratch in about 150 lines of OCaml.
