---
title: "Type-safe CSS"
publishedAt: "2025-10-12"
isDraft: true
tags:
  - "CSS"
  - "Type Safety"
  - "styled-ppx"
  - "OCaml"
description: "CSS has a type system hidden in the spec"
---

Last week I typo'd `display: flexbox` instead of `display: flex`. The browser didn't complain. The page rendered. The layout was just... wrong. I spent twenty minutes checking my JavaScript before opening DevTools and spotting the issue.

If you've written TypeScript, you know the feeling of `const x: number = "hello"` lighting up red before you even save the file. The compiler catches your mistake. You fix it. You move on.

CSS doesn't work that way. Write `color: rde` instead of `color: red`, and nothing happens. No error. No warning. The browser silently ignores your broken declaration and moves on. This is by design—CSS prioritizes resilience. Content must be shown at all costs, even if your styles implode.

But here's the thing: CSS actually has types. The browser knows them and won't tell you when you get them wrong.

## The spec defines the types

Open the [CSS spec for the `display` property](https://drafts.csswg.org/css-display/#the-display-properties) and you'll find something like this:

```
display: [ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>
```

That's not documentation—it's a grammar. It defines exactly which values are valid. `flex` is valid. `flexbox` is not. `block` is valid. `blokc` is not.

Every CSS property has one of these definitions. `color` accepts `<color>` values. `margin` accepts `<length>` or `<percentage>` or specific keywords like `auto`. The spec is rigorous about this.

The browser parses your CSS against these grammars. When something doesn't match, it discards the declaration. But it does this silently, at runtime, after you've already shipped the code. The type system exists—it's just enforced too late to help you.

TypeScript moved type checking from runtime to authoring time. The same idea applies to CSS—validate styles when you write them, not when the browser parses them.

## What this looks like in practice

Imagine writing styles and seeing errors before you refresh:

```css
.button {
  color: rde;           /* Error: "rde" is not a valid <color> */
  display: flexbox;     /* Error: expected "flex", "block", "grid", ... */
  margin: 10 px;        /* Error: unexpected space in "10 px" */
  background: url(;     /* Error: unclosed url() */
}
```

Not linting rules you configure. Not "best practices" someone decided. Actual validation against the CSS specification.

## Turning the spec into a type checker

The CSS spec isn't just documentation—it's a formal grammar. And formal grammars can be transformed into validators.

Take a simple property like `display`. The spec says it accepts values like `block`, `flex`, `grid`, `inline`, `none`, and a few others. In a typed language, you'd model this as:

```reason
type display_value =
  | Block
  | Flex
  | Grid
  | Inline
  | None
  /* ... */
```

Now `display` becomes a function that only accepts `display_value`. Pass it `"flexbox"` and the compiler rejects it. Pass it `Flex` and it works.

The real spec is more complex. It uses combinators:

- `|` means "one of these options"
- `||` means "one or more in any order"
- `&&` means "all of these in order"
- `?` means "optional"
- `+` means "one or more"
- `*` means "zero or more"

These map directly to parser combinators—small functions that combine to parse complex grammars. The CSS spec is essentially a big parser combinator definition waiting to be implemented.

So that's what I did. I took the spec and transformed it into a type checker. Each property becomes a function. Each value type (`<length>`, `<color>`, `<percentage>`) becomes a parser. The combinators wire them together.

When you write `margin: 10px 20px`, the type checker:

1. Parses `10px` as a valid `<length>`
2. Parses `20px` as a valid `<length>`
3. Confirms that `margin` accepts one to four `<length>` values
4. Passes

When you write `margin: 10 px` (with a space), step 1 fails. `10` alone isn't a valid `<length>`. You get an error at compile time, not a silent failure at runtime.

The same approach works for selectors and media queries.

Selectors have their own grammar. `.class` is valid. `..class` is not. `div > p` is valid. `div >> p` is not. The type checker validates selector syntax before you ship broken CSS that silently matches nothing.

Media queries too. `@media (min-width: 768px)` is valid. `@media (min-width: 768)` is not—you need a unit. Every layer of CSS has structure that can be validated.

## styled-ppx

I built this as [styled-ppx](https://github.com/davesnx/styled-ppx), a tool for writing CSS in Reason and OCaml. It's a compile-time preprocessor that validates your styles against the CSS spec and generates the runtime code.

Here's what an error looks like:

```
Error: Property "display" has an invalid value: "flexbox"

  1 | let button = [%css {|
  2 |   display: flexbox;
    |            ^^^^^^^
  3 | |}]

Hint: Did you mean "flex"?
```

The error points to the exact location. It tells you what's wrong. It even suggests what you might have meant. This happens when you compile, not when a user visits your page.

styled-ppx uses [Emotion](https://emotion.sh) under the hood for the runtime—hashing class names, injecting styles, caching. The type checking is purely a compile-time layer that ensures what you write is valid CSS before it ever runs.

## Why Reason/OCaml?

There's an obvious question: why isn't this a TypeScript tool?

Two reasons. First, TypeScript's type system can't express CSS's grammar. You'd need dependent types or something more powerful to validate that `margin` accepts `<length>` values while `color` accepts `<color>` values—and that `10px` is a `<length>` but `10` alone isn't.

Second, I work in Reason and OCaml. The pattern matching and parser combinator libraries made this tractable. Building the same thing in TypeScript would require a different approach—probably a custom compiler plugin or a build-time validator rather than types.

If you're not in the Reason/OCaml ecosystem, styled-ppx isn't directly useful to you. But the concept is portable. Someone could build CSS validation into ESLint, or into a TypeScript transformer, or into a VS Code extension. The spec is public.

CSS-in-JS libraries like styled-components, Emotion, and vanilla-extract offer autocomplete for property names—but autocomplete isn't validation. You can still typo a value, forget a unit, or use a property that doesn't exist. The styles compile. They just don't work.

Type-safe CSS closes that gap. If it compiles, the styles are valid according to the spec. One less category of silent failures to worry about.

---

If you're curious, [styled-ppx is on GitHub](https://github.com/davesnx/styled-ppx). It's been running in production at [Ahrefs](https://ahrefs.com) for years. The documentation covers installation, usage, and the full list of supported CSS features.

And if you're not in the Reason/OCaml world but the idea resonates—maybe it's worth building something similar for your stack. The CSS spec isn't going anywhere.
